// GENERATED FILE, DO NOT MODIFY! YOUR MODIFICATION WILL BE LOST!
package ${e.packageOfJavaDao}.${e.database.name};

import java.math.BigDecimal;
<#if t.hasBlobField>import java.sql.Blob;${'\n'}</#if><#if t.hasClobField>import java.sql.Clob;${'\n'}</#if><#if t.hasArrayField>import java.sql.Array;${'\n'}</#if>
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.JdbcUpdateAffectedIncorrectNumberOfRowsException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import ${e.packageOfJavaModel}.${e.database.name}.${t.javaName};

/**
 * ${t.javaName}${e.daoSuffix}.
 * <br>${t.comment}
 * <br>Generated from ${t.dbName} database table.
 * <br>Created on: ${e.database.modelCreationDate}
 * <br>Database name: ${e.database.name}
 * <br>Generated by ${appname} v${appversion}
 */
@Repository
<#if t.compositePk>
public class ${t.javaName}${e.daoSuffix} implements hu.vanio.easydao.core.Dao<${t.javaName}, ${t.javaName}.Pk> {
<#else>
public class ${t.javaName}${e.daoSuffix} implements hu.vanio.easydao.core.Dao<${t.javaName}, ${t.pkField.javaTypeAsString}> {
</#if>

    /** Selected fields of the database table */
    static final protected String SELECTED_FIELDS = "<#list t.fieldList as field>${field.dbName}<#if field_has_next>, </#if></#list>";

    /** Datasource that can be used for acquiring SQL connections */
    protected DataSource dataSource;
    /** Runs SQL operations */
    protected JdbcTemplate jdbcTemplate;

    @Autowired
    public void setDataSource(@Qualifier("${e.database.name}") DataSource dataSource) {
        this.dataSource = dataSource;
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    /**
     * Reads a domain object with the specified primary key from the datastore 
     <#if t.compositePk>
     * @param pk Primary key
     <#else>
     * @param ${t.pkField.javaName} ${t.pkField.comment}
     </#if>
     * @param readLobFields Specifies whether BLOB/CLOB fields has to be read from the datastore
     * @return ${t.javaName} instance
     */
    @Override
    <#if t.compositePk>
    public ${t.javaName} read(${t.javaName}.Pk pk, boolean readLobFields) {
    <#else>
    public ${t.javaName} read(${t.pkField.javaTypeAsString} ${t.pkField.javaName}, boolean readLobFields) {
    </#if>
        <#if t.compositePk>
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName} where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
        ${t.javaName} retVal = this.jdbcTemplate.queryForObject(query, new ${t.javaName}RowMapper(readLobFields), <#list t.pkFields as field> pk.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        <#else>
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName} where ${t.pkField.dbName} = ?";
        ${t.javaName} retVal = this.jdbcTemplate.queryForObject(query, new ${t.javaName}RowMapper(readLobFields), ${t.pkField.javaName});
        </#if>
        return retVal;
    }

    /**
     * Reads all instances of the domain object from the datastore
     * @param readLobFields Specifies whether BLOB/CLOB fields has to be read from the datastore
     * @return All instances of the domain object
     */
    @Override
    public List<${t.javaName}> readAll(boolean readLobFields) {
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName}";
        List<${t.javaName}> retVal = this.jdbcTemplate.query(query, new ${t.javaName}RowMapper(readLobFields));
        return retVal;
    }

    /**
     * Creates a new primary key instance on the specified domain object instance
     * @param instance The domain object instance
     */
    @Override
    public void createPk(final ${t.javaName} instance) {
    <#if t.compositePk>
        throw new IllegalStateException("Sequence cannot be auto-generated for tables with composite primary key");
    <#else>
      <#if e.sequenceNameConvention.name() == 'PREFIXED_TABLE_NAME'><#assign sequenceName = "SEQ_${t.dbName}"></#if>
      <#if e.sequenceNameConvention.name() == 'PREFIXED_FIELD_NAME'><#assign sequenceName = "SEQ_${t.pkField.dbName}"></#if>
      <#if e.sequenceNameConvention.name() == 'SUFFIXED_TABLE_NAME'><#assign sequenceName = "${t.dbName}_SEQ"></#if>
      <#if e.sequenceNameConvention.name() == 'SUFFIXED_FIELD_NAME'><#assign sequenceName = "${t.pkField.dbName}_SEQ"></#if>
      <#if e.sequenceNameConvention.name() == 'PREFIXED_TABLE_NAME_WITH_FIELD_NAME'><#assign sequenceName = "SEQ_${t.dbName}_${t.pkField.dbName}"></#if>
      <#if e.sequenceNameConvention.name() == 'SUFFIXED_TABLE_NAME_WITH_FIELD_NAME'><#assign sequenceName = "${t.dbName}_${t.pkField.dbName}_SEQ"></#if>
      <#if e.databaseType.name() == 'ORACLE11'>
        String query = "select ${sequenceName}.nextval PK from dual";
      </#if>
      <#if e.databaseType.name() == 'POSTGRESQL9'>
        String query = "select nextval ('${sequenceName}') as PK";
      </#if>
        <#assign pkField = t.pkField>
        this.jdbcTemplate.query(query, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet rs) throws SQLException {
                <#if pkField.readAsString>
                String tmp;
                ${pkField.javaTypeAsString} ${pkField.javaName} = (tmp = rs.getString("PK")) != null ? new ${pkField.javaTypeAsString}(tmp) : null;
                <#else>
                ${pkField.javaTypeAsString} ${pkField.javaName} = rs.get${pkField.javaTypeAsString}("PK");
                </#if>
                instance.set${pkField.javaName?cap_first}(${pkField.javaName});
            }
        });
    </#if>
    }

    /**
     * Creates a new domain object in the datastore based on the specified instance
     * @param instance The domain object instance to create
     * @param createPk Indicates whether a new primary key needs to be created
     * @return The re-read updated domain object instance (it needs to be re-read because of the computed fields)
     */
    @Override
    public ${t.javaName} create(${t.javaName} instance, boolean createPk) {
        String sql = "insert into ${t.dbName} (<#list t.fieldList as field>${field.dbName}<#if field_has_next>,</#if></#list>) values (<#list t.fieldList as field>?<#if field_has_next>,</#if></#list>)";
        if (createPk) createPk(instance);
        Object[] params = new Object[] {
            <#list t.fieldList as field>
            <#if field.array>
            <#if e.databaseType.name() == 'POSTGRESQL9'>
            hu.vanio.easydao.core.postgresql.PostgreSqlArrayFactory.getForType(instance.get${field.javaName?cap_first}())<#if field_has_next>,</#if>
            <#else>
            FIXME: array handling is not yet implemented for Oracle
            </#if>
            <#else>
            instance.get${field.javaName?cap_first}()<#if field_has_next>,</#if>
            </#if>
            </#list>
        };
        this.jdbcTemplate.update(sql, params);

        <#if t.compositePk>
        ${t.javaName}.Pk pk = new ${t.javaName}.Pk(<#list t.pkFields as field>instance.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        return read(pk, false);
        <#else>
        return read(instance.get${t.pkField.javaName?cap_first}(), false);
        </#if>
    }

    /**
     * Updates the specified domain object instance
     * @param instance The domain object instance to update
     * @return The re-read updated domain object instance (it needs to be re-read because of the computed fields)
     */
    @Override
    public ${t.javaName} update(${t.javaName} instance) {
        String sql = "update ${t.dbName} " +
                     "set <#list t.nonPkFields as field>${field.dbName} = ?<#if field_has_next>, </#if></#list> " + 
                     <#if t.compositePk>
                     "where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
                     <#else>
                     "where ${t.pkField.dbName} = ?";
                     </#if>

        Object[] params = new Object[] {
            <#list t.nonPkFields as field>
            <#if field.array>
            <#if e.databaseType.name() == 'POSTGRESQL9'>
            hu.vanio.easydao.core.postgresql.PostgreSqlArrayFactory.getForType(instance.get${field.javaName?cap_first}()),
            <#else>
            FIXME: array handling is not yet implemented for Oracle
            </#if>
            <#else>
            instance.get${field.javaName?cap_first}(),
            </#if>
            </#list>
            <#if t.compositePk>
            <#list t.pkFields as field>
            instance.get${field.javaName?cap_first}()<#if field_has_next>,</#if>
            </#list>
            <#else>
            instance.get${t.pkField.javaName?cap_first}()
            </#if>
        };

        int updRows = this.jdbcTemplate.update(sql, params);
        if (updRows != 1) {
            throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(sql, 1, updRows);
        }

        <#if t.compositePk>
        ${t.javaName}.Pk pk = new ${t.javaName}.Pk(<#list t.pkFields as field>instance.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        return read(pk, false);
        <#else>
        return read(instance.get${t.pkField.javaName?cap_first}(), false);
        </#if>
    }

    /**
     * Deletes the domain object instance specified with its primary key
     <#if t.compositePk>
     * @param pk Primary key
     <#else>
     * @param ${t.pkField.javaName} ${t.pkField.comment}
     </#if>
     */
    @Override
    <#if t.compositePk>
    public void delete(${t.javaName}.Pk pk) {
    <#else>
    public void delete(${t.pkField.javaTypeAsString} ${t.pkField.javaName}) {
    </#if>
        <#if t.compositePk>
        String sql = "delete from ${t.dbName} where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
        int updRows = this.jdbcTemplate.update(sql, <#list t.pkFields as field> pk.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        <#else>
        String sql = "delete from ${t.dbName} where ${t.pkField.dbName} = ?";
        int updRows = this.jdbcTemplate.update(sql, ${t.pkField.javaName});
        </#if>
        if (updRows != 1) {
            throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(sql, 1, updRows);
        }
    }

    /** RowMapper implementation */
    private class ${t.javaName}RowMapper implements RowMapper<${t.javaName}> {
        
        /** Specifies whether BLOB/CLOB fields has to be read from the datastore */
        private final boolean readLobFields;
        
        /**
         * Constructs a new instance
         * @param readLobFields Specifies whether BLOB/CLOB fields has to be read from the datastore
         */
        public ${t.javaName}RowMapper(boolean readLobFields) {
            this.readLobFields = readLobFields;
        }

        @Override
        public ${t.javaName} mapRow(ResultSet rs, int rowNum) throws SQLException {
            String tmp;
            <#if t.hasBlobField>Blob tmpBlob;${'\n'}</#if><#if t.hasClobField>Clob tmpClob;${'\n'}</#if><#if t.hasArrayField>Array tmpArray;${'\n'}</#if>
            <#list t.fieldList as field>
            <#if field.readAsString>
            ${field.javaTypeAsString} ${field.javaName} = (tmp = rs.getString("${field.dbName}")) != null ? new ${field.javaTypeAsString}(tmp) : null;
            <#else>
            <#if !field.blob && !field.clob && !field.array>
            ${field.javaTypeAsString} ${field.javaName} = rs.get${field.javaTypeAsString}("${field.dbName}");
            </#if>
            </#if>
            <#if field.blob>
            byte[] ${field.javaName} = null;
            if (readLobFields) {
                ${field.javaName} = (tmpBlob = rs.getBlob("${field.dbName}")) != null ? tmpBlob.getBytes(1, (int)tmpBlob.length()) : null;
            }
            </#if>
            <#if field.clob>
            String ${field.javaName} = null;
            if (readLobFields) {
                ${field.javaName} = (tmpClob = rs.getClob("${field.dbName}")) != null ? tmpClob.getSubString(1, (int)tmpClob.length()) : null;
            }
            </#if>
            <#if field.array>
            ${field.javaTypeAsString} ${field.javaName} = (tmpArray = rs.getArray("${field.dbName}")) != null ? (${field.javaTypeAsString})tmpArray.getArray() : null;
            </#if>
            </#list>
            return new ${t.javaName}(<#list t.fieldList as field>${field.javaName}<#if field_has_next>, </#if></#list>);
        }
    }

}
