// GENERATED FILE, DO NOT MODIFY! YOUR MODIFICATION WILL BE LOST!
package ${e.packageOfJavaDao}.${e.database.name};

import ${e.packageOfJavaModel}.${e.database.name}.${t.javaName};

import java.math.BigDecimal;
<#if t.hasBlobField>import java.sql.Blob;</#if>
<#if t.hasClobField>import java.sql.Clob;</#if>
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.JdbcUpdateAffectedIncorrectNumberOfRowsException;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

/**
 * ${t.javaName}${e.daoSuffix}.
 * <br>${t.comment}
 * <br>Generated from ${t.dbName} database table.
 * <br>Created on: ${e.database.modelCreationDate}
 * <br>Database name: ${e.database.name}
 * <br>Generated by ${appname} v${appversion}
 */
@Repository
<#if t.compositePk>
public class ${t.javaName}${e.daoSuffix} implements hu.vanio.easydao.core.Dao<${t.javaName}, ${t.javaName}.Pk>, RowMapper<${t.javaName}> {
<#else>
public class ${t.javaName}${e.daoSuffix} implements hu.vanio.easydao.core.Dao<${t.javaName}, ${t.pkField.javaTypeAsString}>, RowMapper<${t.javaName}> {
</#if>

    static final protected String SELECTED_FIELDS = "<#list t.fieldList as field>${field.dbName}<#if field_has_next>, </#if></#list>";

    protected DataSource dataSource;
    protected JdbcTemplate jdbcTemplate;

    @Autowired
    public void setDataSource(@Qualifier("${e.database.name}") DataSource dataSource) {
        this.dataSource = dataSource;
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public ${t.javaName} mapRow(ResultSet rs, int rowNum) throws SQLException {
        String tmp;
        <#if t.hasBlobField>Blob tmpBlob = null;</#if>
        <#if t.hasClobField>Clob tmpClob = null;</#if>
        <#list t.fieldList as field>
        <#if field.readAsString>
        ${field.javaTypeAsString} ${field.javaName} = (tmp = rs.getString("${field.dbName}")) != null ? new ${field.javaTypeAsString}(tmp) : null;
        <#else>
        <#if !field.blob && !field.clob>
        ${field.javaTypeAsString} ${field.javaName} = rs.get${field.javaTypeAsString}("${field.dbName}");
        </#if>
        </#if>
        <#if field.blob>
        byte[] ${field.javaName} = (tmpBlob = rs.getBlob("${field.dbName}")) != null ? tmpBlob.getBytes(1, (int)tmpBlob.length()) : null;
        </#if>
        <#if field.clob>
        String ${field.javaName} = (tmpClob = rs.getClob("${field.dbName}")) != null ? tmpClob.getSubString(1, (int)tmpClob.length()) : null;
        </#if>
        </#list>
        return new ${t.javaName}(<#list t.fieldList as field>${field.javaName}<#if field_has_next>, </#if></#list>);
    }

    /**
     * Reads a domain object with the specified primary key from the datastore 
     <#list t.pkFields as field>
     * @param ${field.javaName} ${field.comment}
     </#list>
     * @return ${t.javaName} instance
     */
    @Override
    <#if t.compositePk>
    public ${t.javaName} read(${t.javaName}.Pk pk) {
    <#else>
    public ${t.javaName} read(${t.pkField.javaTypeAsString} ${t.pkField.javaName}) {
    </#if>
        <#if t.compositePk>
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName} where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
        ${t.javaName} retVal = this.jdbcTemplate.queryForObject(query, (RowMapper<${t.javaName}>)this, <#list t.pkFields as field> pk.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        <#else>
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName} where ${t.pkField.dbName} = ?";
        ${t.javaName} retVal = this.jdbcTemplate.queryForObject(query, (RowMapper<${t.javaName}>)this, ${t.pkField.javaName});
        </#if>
        return retVal;
    }

    /**
     * Reads all instances of the domain object from the datastore
     * @return All instances of the domain object
     */
    @Override
    public List<${t.javaName}> readAll() {
        String query = "select " + SELECTED_FIELDS + " from ${t.dbName}";
        List<${t.javaName}> retVal = this.jdbcTemplate.query(query, (RowMapper<${t.javaName}>)this);
        return retVal;
    }

    /**
     * Creates a new primary key instance on the specified domain object instance
     * @param instance The domain object instance
     */
    @Override
    public void createPk(${t.javaName} instance) {
    }

    /**
     * Creates a new domain object in the datastore based on the specified instance
     * @param instance The domain object instance to create
     * @param createPk Indicates whether a new primary key needs to be created
     * @return The re-read updated domain object instance (it needs to be re-read because of the computed fields)
     */
    @Override
    public ${t.javaName} create(${t.javaName} instance, boolean createPk) {
        String sql = "insert into ${t.dbName} (<#list t.fieldList as field>${field.dbName}<#if field_has_next>,</#if></#list>) values (<#list t.fieldList as field>?<#if field_has_next>,</#if></#list>)";
        if (createPk) createPk(instance);
        Object[] params = new Object[] {
            <#list t.fieldList as field>
            instance.get${field.javaName?cap_first}()<#if field_has_next>,</#if>
            </#list>
        };
        this.jdbcTemplate.update(sql, params);

        <#if t.compositePk>
        ${t.javaName}.Pk pk = new ${t.javaName}.Pk(<#list t.pkFields as field>instance.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        return read(pk);
        <#else>
        return read(instance.get${t.pkField.javaName?cap_first}());
        </#if>
    }

    /**
     * Updates the specified domain object instance
     * @param instance The domain object instance to update
     * @return The re-read updated domain object instance (it needs to be re-read because of the computed fields)
     */
    @Override
    public ${t.javaName} update(${t.javaName} instance) {
        String sql = "update ${t.dbName} " +
                     "set <#list t.nonPkFields as field>${field.dbName} = ?<#if field_has_next>, </#if></#list> " + 
                     <#if t.compositePk>
                     "where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
                     <#else>
                     "where ${t.pkField.dbName} = ?";
                     </#if>

        Object[] params = new Object[] {
            <#list t.nonPkFields as field>
            instance.get${field.javaName?cap_first}(),
            </#list>
            <#if t.compositePk>
            <#list t.pkFields as field>
            instance.get${field.javaName?cap_first}()<#if field_has_next>,</#if>
            </#list>
            <#else>
            instance.get${t.pkField.javaName?cap_first}()
            </#if>
        };

        int updRows = this.jdbcTemplate.update(sql, params);
        if (updRows != 1) {
            throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(sql, 1, updRows);
        }

        <#if t.compositePk>
        ${t.javaName}.Pk pk = new ${t.javaName}.Pk(<#list t.pkFields as field>instance.get${field.javaName?cap_first}()<#if field_has_next>, </#if></#list>);
        return read(pk);
        <#else>
        return read(instance.get${t.pkField.javaName?cap_first}());
        </#if>
    }

    
    /**
     * Deletes the specified domain object instance
     * @param instance The domain object instance to delete
     */
    @Override
    public void delete(${t.javaName} instance) {
        String sql = "delete from ${t.dbName} " +
                     <#if t.compositePk>
                     "where <#list t.pkFields as field>${field.dbName} = ?<#if field_has_next> and </#if></#list>";
                     <#else>
                     "where ${t.pkField.dbName} = ?";
                     </#if>

        Object[] params = new Object[] {
            <#if t.compositePk>
            <#list t.pkFields as field>
            instance.get${field.javaName?cap_first}()<#if field_has_next>,</#if>
            </#list>
            <#else>
            instance.get${t.pkField.javaName?cap_first}()
            </#if>
        };

        int updRows = this.jdbcTemplate.update(sql, params);
        if (updRows != 1) {
            throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(sql, 1, updRows);
        }
    }

}
